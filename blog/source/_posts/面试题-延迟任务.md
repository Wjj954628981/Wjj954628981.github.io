---
title: 面试题-延时任务
date: 2020-03-09 00:36:33
tags: [面试, 算法]
---

在软件系统设计中，延时任务的需求比比皆是：客户端请求一定时间后自动断开；订单系统下单后一段时间执行操作；等等。本篇文章对如何实现一个高效且贴合实际场景的延时任务服务进行大致的讲解。

<!--more-->

# 扫表
将延时任务按照过期时间**有序**存储起来（MySQL），然后进行**短间隔轮训**，遇到截止的任务则执行并删除。

> 当应用数据量较大的情况下，会对MySQL实例造成较大的压力，不适用此解决方案。

# Timer
Golang内置了**Timer**。Timer是通过最小堆实现的，其创建和删除的时间复杂度均为$O(log n)$。

> 在现代web服务器的高并发程度，百万级的延时任务数量下，Timer的性能会遇到问题。

# 时间轮
时间轮的本质就是对未来时间按照相同结构实现分层hash，并将延时任务按照链表格式注入hash桶。

## 简单时间轮
简单时间轮就是**单个循环列表**。每一项代表单位时间u，总项数为n，则该时间轮代表最大延时区间为n*u的延时任务存储空间。

> 简单时间轮由于其延时区间限制，仅能通过提高u和n来实现扩张。提高u则会导致延时任务的时间精度变差，而提高n则会导致空间浪费（大量桶中无延时任务）

## 层级时间轮
按照简单时间轮的结构进行分层设计，使得上层时间轮中的每一项均指向一个完整的下层时间轮，这种方式下延时区间按照**n的指数级**进行扩张。

当最底层时间轮运行一周，上层时间轮则运行一格，以此类推（钟表就是一个多层时间轮，只不过在满一天后并没有选择再次按照60倍进行扩张）。

## 时钟驱动方式
常规情况下，需要一个线程在每个时间单位流逝后weak up驱动时间轮前进一格。但是在这种方式下，如果时间单位很小且延时任务很少，则会非常低效。

参考kafka的层级时间轮实现中，利用了Java内置的**DelayQueue**结构，将全部层时间轮中包含延时任务的桶均加入同一个DelayQueue中，当DelayQueue中有桶到期后再一次性推动时间轮走多格。

> 尽管DelayQueue插入删除的时间复杂度为$O(log n)$，但是由于层级时间轮桶的数量增加为线性，因此不会造成效率上的问题。

### 参考
- [层级时间轮的 Golang 实现](http://russellluo.com/2018/10/golang-implementation-of-hierarchical-timing-wheels.html)