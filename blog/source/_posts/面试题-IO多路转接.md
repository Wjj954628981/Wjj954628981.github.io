---
title: 面试题-I/O多路转接
date: 2020-03-13 02:00:45
tags: [面试, 操作系统]
---

Nginx是一款在高并发场景性能非常优越的web服务器，追究其高效的原因，就在于使用了**I/O多路转接**技术。I/O多路转接技术究竟为何？为什么其能承载万级的并发？接下来通过这篇文章对其进行详细的讲解。

<!--more-->

# 概述

I/O多路转接（[I/O Multiplexing](http://wiki.c2.com/?IoMultiplexing)），又称为I/O多路复用，实现了以下操作：**通过I/O多路转接，程序可以检查或阻塞多个I/O流，当其中一个流处于活跃状态会通知程序处理流上的数据。**

## 源起
当程序需要读**一个文件描述符**时，需要通过while循环阻塞地对该文件描述符进行判断；但是当需要读**多个文件描述符**时，上述策略就失效了，因为当程序阻塞在其中一个描述符上时，其他文件描述符也可能会有有效数据。那么如何解决呢？

## 解决

### 多进程/多线程
我们来观察**telnet**命令的实现。
该命令实现读取用户终端输入，将输入写入网络连接上，并从网络连接读到返回数据，显示在用户终端（标准输出）；在网络的另一端，telnet守护进程读取用户键入的命令，并将所读命令传送给shell，就如同用户登录到远端机器一样。telnet有两个输入、两个输出，我们不能对任意一个输入进行阻塞读，因为我们无法判断到底哪个输入会得到数据。

{% asset_img telnet命令.jpg %}

这种特殊问题的解决办法是，将一个进程**fork**变为两个进程，每个进程处理一条数据通路进行阻塞读。

> - 两个进程如何**终止**？当子进程收到网络连接的文件结束符，子进程终止并向父进程发送**SIGCHLD**信号，通知父进程也进行终止操作；但如果父进程收到用户的文件结束符进行终止，则父进程需要主动向子进程发送**SIGUSR1**信号通知子进程终止。
> - 我们可以不使用两个进程，而是使用一个进程的两个线程来实现上述操作，虽然可以减少终止操作的复杂度，但是需要处理两个线程之间的同步，可能会变得更加复杂。

### 轮循
对于多个读文件描述符设置为**非阻塞**读并进行**轮询**，如果无数据则continue，有数据则读取并处理。

> 该方式下，由于大部分情况均是无数据可读，因此执行read系统浪费了CPU时间。

### 异步I/O
通过异步I/O，当文件描述符准备好时，用一个**信号**来唤醒当前进程读取该文件描述符数据。

> 由于要区分究竟读取哪个文件描述符获得数据，因此有几个文件描述符就需要几个不同的信号，很明显能用的信号数量远小于可能需要监听的文件描述符数量。

### I/O多路转接
分析上述解决办法，都具有一定的特殊性，无法针对于普遍情况。因此，I/O多路转接应运而生，非常优雅地解决了上述问题。

# 实现
当一个进程需要对多个文件描述符进行I/O时，将全部描述符放到一个**列表**中，然后**阻塞**地调用I/O多路转接函数，直到列表中有文件描述符准备好I/O。

> 可以类比为：对每个文件描述符**注册回调**函数，当其准备好I/O操作时执行回调，通知主进程处理数据。

## select

## poll

## epoll

### 参考
- 《Unix环境高级编程-第十四章.高级I/O》
- [Linux epoll模型详解及源码分析](https://blog.csdn.net/zhaobryant/article/details/80557262)