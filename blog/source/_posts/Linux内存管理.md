---
title: Linux内存管理-从操作系统角度看可执行文件的装载
date: 2020-02-25 02:29:46
tags: [操作系统]
---

一直以来有些疑惑：一个可执行文件，从开始执行到结束的过程中，操作系统究竟做了哪些操作。接下来，我将循序渐进地分析整个过程中发生了哪些事情。

<!--more-->

# 目标文件
编译器编译源码后生成的文件叫做目标文件，我们来看一个简单的程序被编译成目标文件后的结构。
{% asset_img 目标文件.jpg %}
假设上图目标文件的格式是ELF。File Header描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，File Header还包括一个**段表**，一个描述文件中各个段在文件中的偏移及段属性的数据。**.bss段**只是为未初始化的全局变量和局部静态变量预留位置。

##### 程序指令与数据分开存放的原因
- 指令和数据匹配的权限不同，数据对于进程应该是可读写，指令对于进程应该是只读，这样可以防止程序指令被改写。
- 可以提高程序的局部性，增加CPU的缓存命中率。
- 当程序存在多个副本时，指令可共享。

# 链接
通过链接器，可以多个目标文件的相似段合并加工后并成一个可执行文件。
{% asset_img 相似段合并.jpg %}
在Linux中的shell执行./a.out即可运行该程序，但操作系统是怎么做的呢？我们接下来就进行解析。

# 进程创建-可执行文件的装载
每个Linux程序都有一个运行时内存映像（进程虚拟空间，其间地址即为逻辑地址），也就是各个段的布局。读取可执行文件头，建立内存映像与可执行文件的映射关系。
{% asset_img ELF与进程虚拟空间映射.jpg %}
> - Linux将进程虚拟空间中的一个段叫做虚拟内存区域（VMA, Virtual Memory Area）。
> - 在分配栈、堆段运行时地址的时候，链接器会使用空间地址空间布局随机化（ASLR），但是相对位置不会变。

最后将CPU指令寄存器设置为可执行文件入口，启动运行。

# Linux分段&分页机制
执行完上述操作后，其实可执行文件的真正指令和数据都没有别装入内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚拟内存之间的映射关系而已。

现在程序的入口地址为0x08048000，刚好是代码段的起始地址。当CPU打算执行这个地址的指令时，发现页面0x8048000~0x08049000（一个页面一般是4K）是个空页面，于是它就认为是个页错误。

此时操作系统根据进程虚拟地址空间与可执行文件间的映射关系找到页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，并在进程虚拟地址页面与物理页面间建立映射，最后把文件中页面拷贝到物理页面，进程重新开始执行。

那么上述进程虚拟空间与物理页面是怎么建立映射的呢？

## 分段：逻辑地址->虚拟地址（线性地址）
**Linux分段**机制提供了隔绝各个代码、数据和堆栈区域的机制，它为每个程序各分配一套段称为**段选择符**，存储在cs、ds、ss等寄存器中（切换进程上下文环境会加载对应进程的段选择符）。

**段选择符的本质是一个索引值**。通过段选择符在**GDT**（Global Descriptor Table）或LDT（Local Descriptor Table）中可以定位到相应的**段描述符**。

从段描述符中取得段基地址，加上进程虚拟空间地址（本质上是一个**偏移量**），就形成为一个线性地址。

> 上述的转换均在**MMU（Memory Management Unit）**中进行处理。

##### Linux分段机制的原因
- 历史原因导致延续旧的分段
- 指令共享（与目标文件分段一致，单纯分页无法保证页内全部内容可共享）
- 程序地址受限与虚拟地址，分段方便于扩张

### GDT和LDT
#### Linux Real Model
在Real Mode下，我们对一个虚拟地址（线性地址）的访问是通过Segment:Offset的方式来进行的。其中Segment是一个段的Base Address，一个Segment的最大长度是64KB，这是**16-bit**系统所能表示的最大长度；而Offset则是相对于此Segment Base Address的偏移量。

由此我们可以看出，一个段需要具备两个因素：**Base Address、Limit**（段的最大长度）；而访问一个虚拟地址则需要：段及段的Base Address、Offset，且Offset应该小于段的Limit（对于16-bit系统，Limit不要指定，默认为最大长度64KB，而16-bit的Offset也永远不可能大于此Limit）。

在实际编程的中，使用16-bit段寄存器CS（Code Segment），DS（Data Segment），SS（Stack Segment）来指定Segment，CPU将段寄存器中的数值向左偏移4-bit就成为20-bit的Base Address。

#### Linux Protected Mode
到了Protected Mode，内存的管理模式分为两种，段模式和页模式，其中页模式也是基于段模式的。也就是说，Protected Mode的内存管理模式事实上是：纯段模式和段页式。因此，我们这里仅考虑段模式。

对于段模式来讲，访问一个内存地址仍然使用Segment:Offset的方式。由于Protected Mode运行在**32-bit**系统上，那么Segment的两个因素：Base Address、Limit也都是32位的。另外，Protected Mode，顾名思义，又为段模式提供了保护机制，一个段除Base Address、Limit外还需要规定对自身的访问权限（Access）。因此在Protected Mode下，一个段需要具备三个因素：**Base Address、Limit、Access**，它们加起来放在一个**64-bit**长的数据结构中，被称为**段描述符**。

这种情况下，16-bit的段寄存器无法载入64-bit长的段描述符（尽管每个段寄存器事实上有一个64-bit长的不可见部分，但对程序员来说，段寄存器就是16-bit的）。因此我们将这些64-bit的段描述符放入一个数组，段寄存器仅存储段描述符在数组中的索引值（将段寄存器中的高13 -bit的内容作为索引），这个数组即为**GDT**。

> 正如GDT的名称Global Descriptor Table，GDT是全局可见的，且在GDT中存放的不仅仅是段描述符，还有其它64-bit长的描述符。

#### GDTR
GDTR是Intel的设计者为存放GDT内存入口地址所设计的寄存器。

#### LDT
LDT是类似于GDT的数据结构。Local Descriptor Table，顾名思义，是局部性质的描述符表，且系统中可能存在多个。

LDT仅对引用他们的任务可见，且每个任务最多可以拥有一个LDT。另外，每一个LDT自身作为一个段存在，他们的段描述符被放在GDT中。

> GDT为一级描述符表，LDT为二级描述符表。

## 分页：虚拟地址（线性地址）->物理地址
从虚拟地址转换到物理地址的过程，需要Linux分页机制来实现。

Linux分页机制会将线性地址，按照固定大小（一般为4k）划分页面，然后将线性地址页面映射到物理地址的页面。

Linux操作系统将线性地址与物理地址的映射关系，以及用于产生页错误异常的信息，包含在存储于内存中的**页目录**和**页表**。**页表可以看作以4k为单位的物理地址索引数组**。

线性地址的高20位构成这个数组的引索值，用于选择对应页面的物理基地址；低12位给出了偏移量。

页表中的页表项占32-bit。由于只需要其中20位来存放页面的物理基地址，剩下的12位可用于存放诸如页面是否存在（不存在会产生**缺页中断**）等属性信息。

> 上述的转换均在**MMU（Memory Management Unit）**中进行处理。

> 页表存储于**进程控制块（PCB）**中。PCB是操作系统中最重要的记录性数据结构，**每一个进程均有一个PCB**，在创建进程时建立PCB，并伴随进程运行的全过程，直到进程撤消而撤消。PCB中除了页表外还存储了：进程状态，程序计数器，CPU寄存器，CPU调度信息，内存管理信息，记账信息，I/O状态信息，等。

#### 页表项过多
默认以4k作为页表大小，如果是32位机器，则有$2^32/2^12=2^20$条页表，如果是64位则页表项更多，要如何解决呢？

其实页目录就是解决的办法，即通过增加多级索引的方式来解决索引项过多。

- 页目录被存放在1个4k页面中，具有$2^10$个4字节长度的表项（PTE，page table entry），这些表项指向具体的页表。页目录由线性地址高10位作为引索。

- 页表也被存放在1个4k页面中。通过线性地址高10位获取指向第二级页表的指针，再加上中间10位，就可以在相应页表中获得物理地址的高20位，再加上线性地址的低12位，就组成了一个完整的32位物理地址。

#### 多级页表优点
- 如果一级页表中的一个PTE为空，那么相应的二级页表就根本不会存在。这是一种巨大的潜在节约。
- 只有一级页表才需要常驻内存。虚拟内存系统可以在需要时创建、页面调入或者调出二级页表，从而减轻内存的压力。

### 参考
1. 《程序员的自我修养》
2. [分析linux下如何运行一个执行文件](https://blog.csdn.net/wrx1721267632/article/details/52056910)
3. [malloc 背后的系统知识](http://legendtkl.com/2017/03/21/malloc-os-knowledge/)
4. [GDT（全居描述符表）和LDT（局部描述符表）](https://blog.csdn.net/wrx1721267632/article/details/52056910)
5. [linux内存管理---虚拟地址、逻辑地址、线性地址、物理地址的区别](https://blog.csdn.net/yusiguyuan/article/details/9664887)