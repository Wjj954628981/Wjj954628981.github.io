---
title: BitMap & Bloom-Filter
date: 2019-05-20 18:50:16
tags: [算法]
---

所谓BitMap就是用一个bit位来标记某个元素所对应的value（0或1），而key即是该元素（一般为Hash）。由于BitMap使用了bit位来存储数据，因此可以大大节省存储空间。

<!--more-->

# BitMap算法
### 1.基本思想
对{4,7,2,5,3}进行排序，假设有8 bit的空间，将对映index置为1，结果如下：
|0|0|1|1|1|1|0|1|
|-|-|-|-|-|-|-|-| 对上面值为1的index按照顺序输出即完成排序：{2,3,4,5,7}。
### 2.Map映射
假设需要排序的数的总数为**n**，1 int为32 bit，则需要申请数组为**map[floor(n/32)]**。

对于10进制数k，在map中的索引为**ceil(k/32)**，在对映int数二进制的位置为**n%32**。

用位运算代替上述：```map[ceil(k/32)] |= 1 << n % 32```即```map[k>>5] |= 1 << (k & 0x1F)```。

--- 

# Bloom-Filter

### 1. 算法简介
Bloom-Filter，即**布隆过滤器**，通过位数组表示一个集合，并判断一个元素是否属于该集合。

Bloom-Filter有可能出现**错误判断**，但不会漏掉判断。即如果判断一个元素不在集合，那就一定不在；但如果判断一个元素在集合中，则有一定概率判断错误。因而Bloom-Filter不适合零错误的应用场合。

Bloom-Filter优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

### 2. 基本思想
Bloom-Filter算法的核心思想就是利用**多个不同的Hash函数**来解决**Hash碰撞**。

判断一个元素是否属于集合，最直接的想法就是将集合中元素与要判断的元素一一进行判断。但是当集合数量极其大的时候，尽管可以通过方式将每个元素所占内存减小，但该方式的空间和时间消耗依然很大。

联想到**Hash Table**数据结构，通过一个Hash函数将每个元素都转换为位数组的一个bit，则能极大的减小时间空间消耗。

但是Hash存在**碰撞**问题，即同一个元素经过Hash函数处理可能得到同样的结果。

为了解决碰撞问题，可以通过**引入多个Hash函数**。如果通过其中的一个Hash判断元素不在集合中，那么该元素一定不在集合中；尽管所有的Hash函数判断该元素都在集合中，该元素也有一定概率不在集合中。

### 3. 优缺点
1. 无法删除某个元素(bit怎么删==)。

**Counting Bloom Filter**支持删除操作。它将标准Bloom Filter位数组的每一位扩展为一个小的计数器(Counter)，在插入元素时给对应的k(哈希函数个数)个Counter的值分别加1，删除元素时给对应的k个Counter的值分别减1。
2. Hash函数会影响算法实际效果。

### 4. Hash选择及错误率
Bloom-Filter有如下参数：
|m|n|k|f|
|-|-|-|-|
|bit数组的宽度(bit数)|加入其中的key的数量|Hash函数个数|False Positive的比率|
False Positive满足如下公式：

$$f=(1-(1-\tfrac{1}{m})^{kn})^k≈(1-e^{\tfrac{-kn}{m}})^k$$

可以根据上述公式对$f$计算最小值。
