---
title: 面试题-锁
date: 2020-03-01 00:37:25
tags: [面试]
---

锁是保证并发环境数据访问一致性、有效性非常重要的机制，也是面试题中必考问题之一。

<!--more-->

# 锁的类型
锁从宏观上分类，可以分为**乐观锁**和**悲观锁**两种类型。

## 乐观锁
乐观锁是一种乐观思想。
乐观锁认为数据操作读多写少，遇到并发写的可能性低，每次去拿数据时都认为别人不会进行数据修改，因此不进行加锁。但在更新时会先判断在此期间别人是否更新过该数据，如果有过更新则放弃操作。

判断是否更新过的方式有两种：**CAS机制**和**版本号机制**。

### CAS机制
当乐观锁需要进行更新时，判断写入内存位置数据值与进行比较的预期值（即读取到的值）是否一致，如果一致则将拟写入的新值写入内存完成更新。

##### 更新失败后CAS如何操作？
许多CAS的操作是**自旋**的，如果更新失败则会一直重试直到操作成功。
在并发冲突概率大的高竞争环境下，如果CAS一直失败重试，会导致CPU开销较大。
可以通过引入退出机制，如重试次数超过一定阈值后失败退出。当然，更重要的是避免在高竞争环境下使用乐观锁。

##### CAS包含Compare和Swap两个操作，如何保证原子性？
CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证。

##### ABA问题
假设有两个并发操作：并发1读取数据为A；并发2先将数据修改为B，再将数据修改回去为A。此时，如果并发1进行CAS操作，则可以完成更新，然而实际数据已经被并发2进行过更新。

ABA问题看似没有危害，实则在某些场景（如数据为栈顶，经过多次变化栈顶数据未变化，但实际上栈可能已经发生变化）会带来隐患。

### 版本号机制
版本号机制的基本思路是，在数据中增加一个version字段表示该数据的版本号，每当数据完成更新则版本号+1。
查询数据的同时获得该数据的版本号Va，当需要进行更新时，再次查询该数据版本号Vb并与Va做对比，如果一致则可以进行更新操作。

## 悲观锁
悲观锁是一种悲观思想。
悲观锁认为数据操作写多读少，遇到并发写的可能性高，每次去拿数据时都认为别人会进行数据修改。因此在每次读写数据时均会对该数据上锁，这样其他人想要读写该数据就需要block直到加锁方释放锁。

# 锁相关名词介绍

## 互斥锁
互斥锁（Mutex）提供对资源（临界资源）的独占访问。

> **信号量**（semaphore）是一种更高级的同步机制，Mutex可以说是semaphore在仅取值0/1时的特例。Semaphore可以有更多的**取值空间**，用来实现更加复杂的同步，而不单单是线程间互斥。

### 临界资源
临界资源是一次仅允许一个进程占有的共享资源。各进程采用互斥的方式，实现对该资源的共享。

### 临界区
每个进程中访问临界资源的代码块称为临界区。每次仅允许一个进程进入临界区，其他想要进入临界区的进程block挂起。另外，不允许进入临界区的进程运行时间过长。

## 自旋锁
自旋锁是一种互斥锁的实现方式。相比一般的互斥锁在等待时期放弃CPU，自旋锁则是不断循环并测试锁的状态，就这样一直占用这CPU。
由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，且比较适用于**锁使用者保持锁时间比较短的**情况。
自旋锁可能存在两个问题：
- **占用过多CPU资源**。因此自旋锁实现一般会有一个参数限定最多持续尝试次数，超出后放弃当前time slice，等下一次机会。
- **死锁**。接下来章节详细对死锁进行分析。

## 读写锁
读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成**读者**和**写者**，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。
这种锁相对于自旋锁而言，能**提高并发性**，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。
**写者拥有排他性**，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。

## 死锁
死锁是指两个或两个以上的线程在执行过程中，由于**竞争资源**或者由于**彼此通信**而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 死锁的产生条件
- **互斥条件**：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
- **请求和保持条件**：当进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件**：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
- **环路等待条件**：在发生死锁时，必然存在一个进程-资源的环形链。

> 对死锁产生的条件进行白话总结如下：
> 
> **在进程排他性占用资源，阻塞而不释放资源，且无法被其他进程剥夺资源的情况下，如果出现进程-资源的环形链，则会发生死锁。**

### 预防死锁的基本方式
从死锁的产生条件出发，凡是可以破坏产生条件的方式，均可以预防死锁的产生。
- **一次性分配资源**：一次性分配所有资源，这样就不会再有请求了（破坏条件2）
- **全部资源或0资源**：只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏条件2）
- **可剥夺资源**：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏条件3）
- **资源有序分配法**：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏条件4）

### 避免死锁（银行家算法）
预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得较满意的系统性能。

#### 银行家算法的实现思想
允许进程动态地申请资源，系统在每次实施资源分配之前，先计算资源分配的安全性。若此次资源分配安全（即资源分配后，系统能按某种顺序来为每个进程分配其所需的资源，直至最大需求，使每个进程都可以顺利地完成），便将资源分配给进程，否则不分配资源，让进程等待。

#### 银行家算法的数据结构
- 可利用资源向量**Available**：含有m个元素的数组，Available[j]=K表示系统中现有Rj类资源K个。
- 最大需求矩阵**Max**：n*m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。Max[i][j]=K表示进程i需要Rj类资源的最大数目为K。
- 分配矩阵**Allocation**：n*m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。Allocation[i][j]=K表示进程i当前已分得Rj类资源的数目为K。
- 需求矩阵**Need**：n*m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源仍需要数量。Need[i][j]=K表示进程i还需要Rj类资源K个方能完成任务。

> n代表进程数，m代表资源数。

根据上述定义，易得：**Need[i][j] = Max[i][j] - Allocation[i][j]**

#### 银行家算法
定义申请矩阵**Request-i**：为含有m个元素的数组，Request-i[j]=K表示进程Pi需要Rj类资源的数量为K。

整个银行家算法的判断逻辑如下：
1. if Request-i[j] > Need[i][j] {return "申请的资源数已经超过它所宣布的最大值"}
2. if Request-i[j] > Available[i][j] {return "尚无足够资源"}
3. 修改数据结构值：Available[j] -= Request-i[j] Allocation[i][j] += Request-i[j] Need[i][j] -= Request-i[j]
4. 执行安全性算法，判断分配该资源后系统是否处于安全状态。若安全，则完成此次资源分配；否则，恢复资源分配到之前状态，进程Pi继续等待。

执行安全性算法前需要定义两个变量：Available数组的拷贝**Work**；含有n个元素初始化为false的布尔数组**Finish**，表示系统是否有足够的资源分配给进程使之运行完成。

安全性算法伪代码如下：
```
while (if can find (Finish[i] == false && Need[i][j] <= Work[i][j])) {
    //Pi获得资源并顺利进行结束，释放资源
    Work[j] += Allocation[i][j];
    Finish[i] = true;
}
if (all value in Finish is true) {
    //系统安全状态
    return true;
}
return false;
```

### 死锁检测
为每个进程和资源进行编码，然后建立资源分配表和进程等待表。

### 解除死锁
- **剥夺资源**：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。
- **撤消进程**：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止。
> 所谓代价是指优先级、运行代价、进程的重要性和价值等

# Golang中的锁
**golang的锁在源码的sync包中，包含了各种多任务的同步方式。**
主要实现的结构体有：
- runtime / sema（信号量）
- sync / atomic （原子操作）
- sync / mutex （互斥锁）
- sync / RWMutex （读写锁）

### 参考
1. [java 中的锁 -- 偏向锁、轻量级锁、自旋锁、重量级锁](https://blog.csdn.net/zqz_zqz/article/details/70233767)
2. [【BAT面试题系列】面试官：你了解乐观锁和悲观锁吗？](https://www.cnblogs.com/kismetv/p/10787228.html)
3. [什么是临界资源和临界区](https://blog.csdn.net/u013272948/article/details/53929572)
4. [什么是死锁，产生死锁的原因及必要条件](https://blog.csdn.net/hd12370/article/details/82814348)
5. [银行家算法](https://www.cnblogs.com/Lynn-Zhang/p/5672080.html)